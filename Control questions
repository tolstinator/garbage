1. Чем java отличается от с++?
По GC: в Java память освобождается автоматически от неиспользуемых данных (на которых уже нет ссылок (allocated)). В C++ разработчик должен сам освобождать память от ненужных данных.

2. Что такое менеджер памяти?
Менеджер памяти, это программа, которая обрабатывает запросы прикладных программ, на доступ к использованию памяти.

3. Какой механизм используется в Java для управления памятью?
Используется JMM, в состав которой входит GC.

4. Опишите процесс работы сборщика мусора?
GC следит за использованием памяти, в частности за размером свободной памяти, выделенной программе. Если её становится слишком мало, то GC запускает процесс сборки мусора (garbage collection). Можно запросить у GC запустить сборку в любое время, но нельзя запустить её принудительно.

5. Какие алгоритмы сборщика вы знаете?
JVM разделяет память на две области:
1) heap - данные;
2) non-heap - само приложение.
heap состоит из нескольких областей:
1) young generation - туда попадают недавно появившиеся объекты;
2) old generation - попадают объекты, которые достаточно давно находятся в памяти.
Процессы GC подразделяются на:
1) young generation collection (minor collection) - "малая сборка", затрагивает только young generation; выполняется часто;
2) full generation collection (major collection) - затрагивает все области; выполняется, когда размер свободной памяти близится к 0.

6. Чем отличаются сборщики мусора?
1) Serial — самый простой, при его работе приложение останавливает свою работу. Остановка называется термином Stop-The-World - STW. Выполняется в одном потоке.
    a) Young generation collection. Представляет из себя процесс копирования. Heap делится на области: Eden, Survivor0, Survivor1 и Tenured. Первоначально, объекты появляются в Eden. Когда Eden заполняется до конца, то из него убираются мёртвые объекты, а оставшиеся помещаются в одну из областей Survivor. При следующем заполнении Eden опять мёртвые объекты удаляются, а оставшиеся, но уже вместе с имеющимися в одной из Survivor, перемещаются в пустую Survivor. И так повторяется несколько раз. Одна из областей Survivor всегда пустая. Когда одна из областей Survivor оказывается заполненной - при очередной итерации объекты из неё перемещаются в Tenured, а из Eden - в свободную Survivor.
    b) Full generation collection. Представляет из себя процесс уплотнения. В определённый момент заполненной уже оказывается Tenured (old generation), и запускается процесс full generation collection. Состоит из 2 этапов: удаление мёртвых объектов из Tenured и уплотнения оставшихся (дефрагментация). Процесс уплотнения носит название Mark-Sweep-Compact.
2) Parallel — при его работе приложение останавливает свою работу. Выполняется в нескольких потоках. Организация работы с областями памяти отличается тем, что область Tenured делится между потоками выполнения.
3) Concurrent Mark Sweep (CMS) — при его работе приложение не останавливает свою работу. Выполняется в нескольких потоках. Отличия от Serial и Parallel в организации работы с областями памяти:
    a) full generation collection не затрагивает Young generation.
    b) GC не дожидается, когда область Tenured заполнится, а всегда поддерживает её в компактном состоянии.

7. Расскажите про утилиты для анализа памяти?
Встроенные в JDK:
1) jmap, jstat, jstack, jconsole. Позволяют определять состояние памяти и GC (размеры областей, их состояние, количество потоков, срабатываний GC, объектов) во время работы Java-приложения. jconsole - с GUI.
2) jps. Показывает processor-id процесса Java-приложения. Нужно для указания его в других утилитах.

8. Что такое ссылки?
Ссылка на область памяти, в которой находится объект.

9. Какие типы ссылок вы знаете?
10. Чем они отличаются?
1) StrongReference (тип ссылок по умолчанию).
2) SoftReference. Позволяет указать GC, что объект на который она ссылается можно удалить, если он доступен только по цепочке SoftReference. Только, если в этом есть необходимость.
3) WeakReference. Позволяет указать GC, что объект на который она ссылается нужно удалить, если он доступен только по цепочке WeakReference.
4) PhantomReference. Позволяет управлять финализацией объекта на уровне приложения, не средствами GC. Ссылка на объект после его удаления GCом помещается в очередь ReferenceQueue и будет доступна. И используя это можно на уровне приложения настроить правильное управление ресурсами.

11. Расскажите про String pool, Int pool.
String pool - это место в heap, в котором хранятся строковые литералы. Это возможно потому, что строки в Java - неизменяемые. Если мы создаём новую строку, то сначала ищется такая строка в String pool, и только если её нет, создаётся там новая строка. При использовании оператора "new" новая строка создаётся в любом случае. Пример:
    String cat1 = "cat";
    String cat2 = "cat";
    String cat3 = new String ("cat");
Здесь cat1 == cat2 и cat1 != cat3.
Integer pool - это зарезервированный в heap пул целых чисел в диапазоне от -128 до 127, ссылки на которые возвращаются при создании объектов Integer со значением в этом диапазоне, без ключевого слова new. Если использовать оператор "new", то Integer pool не используется. Пример:
    Integer i1 = 100;
    Integer i2 = 100;
    Integer i3 = 130;
    Integer i4 = 130;
    Integer i5 = new Integer(100);
Здесь i1 == i2, i3 != i4 и i1 != i5.

12. Расскажите о String.intern.
string.intern() ищет в String pool строку, для которой метод equals(string) == true, и возвращает ссылку из String pool. Если подходящей строки в String pool нет, то значение string добавляется в String pool и возвращается ссылка на это значение.

13. Расскажите, что такое профайлер?
Профайлер - это утилита, которая показывает, например:
    - как используется память приложением;
    - какой подход в кодировании (архитектура) является наиболее эффективным по производительности и затраченным ресурсам;
    - последствия распараллеливания выполнения приложения;

14. Расскажите, как использовать VisualVM.
Утилита VisualVM входит в состав JDK. Позволяет проводить профилирование/сэмплирование работы приложения.
Позволяет также подключаться к удалённым (remote) java-процессам.

15. Расскажите, чем отличается sampling от profiling? Это типы аудита. Режим работы в профайлере.
Профилирование изменяет код программы, вставляя в классы методы, которые будут отчитываться о работе профайлеру. Таким образом повышается точность работы профайлера, но само изменение кода может привести к непредсказуемым последствиям, особенно в больших веб-приложениях.
Сэмплирование - создание множества срезов состояния системы во время работы приложения с последующим их анализом. Точность работы уменьшается, но это более безопасно.

16. Расскажите о benchmark. Приведите примеры кода.
При бенчмарке измеряется скорость выполнения отдельных методов (микробенчмарк).
Используется Java Microbenchmark Harness (JMH).
Обрабатываемый код программы без изменений помещается внутрь цикла, прогоняется некоторое количество раз, а затем общее время выполнения делится на это количество.
Этот код помечается аннотацией @Benchmark.
Также аннотациями можно задать тип бенчмарка, количество рабочих прогонов, количество "прогревочных" прогонов и т.д.

17. Расскажите о методы finalized.
Он выполняется, когда GC решит, что объект нужно удалить. Его можно переопределить, но нельзя точно установить, когда он сработает, поэтому прописывать закрытие ресурсов в нём вручную нежелательно. В этому случае лучше использовать PhantomReference у объектов.

18. Расскажите о методы clone? Deep clone and shallow clone.
Клонирование - это один из способов создания объекта.
Объект создаётся путём создания объекта класса того объекта, из которого вызывается клонирование. Затем копируются все данные из объекта-источника - в новый класс.
Класс объекта-источника должен реализовывать интерфейс Cloneable, иначе выбрасывается исключение CloneNotSupportedException.
Существует два типа клонирования:
1) поверхностное (shallow) - поля клонируются один в один, т.е., поля ссылочных типов будут содержать в клоне ту же ссылку, что и а источнике;
2) глубокое (deep) - ссылочные поля клонируются своими методами clone(), т.е., создаётся также копия и ссылочных полей.
Степень погружение в клонирование определяется разработчиком.

19. Расскажите о Stack, Heap.
Heap (куча) - часть памяти в Runtime, которая выделяется для хранения данных приложения. Все объекты, создаваемые в приложении, помещаются в кучу. Пока они живы - они доступны из любого места приложения.
Stack (стек) - часть памяти в Runtime, которая функционирует по принципу LIFO. Когда программа начинает выполнять какой-либо метод, в стеке формируется блок, в котором будут содержаться локальные переменные примитивных типов и ссылки на локальные переменные ссылочных типов в куче. Когда метод завершает свою работу, то блок для метода в стеке вместе со всеми примитивами и ссылками удаляется и программа переходит к вызывающему методу, а в стеке текущим становится блок уже для этого метода.
Стек меньше кучи, т.к. в нём содержатся только данные цепочки текущих вызываемых методов и для ссылочных типов хранятся только ссылки. Из-за этого работа со стеком проходит быстрее, чем с кучей.


References:

https://habr.com/ru/post/112676/ - GC
https://habr.com/ru/post/169883/ - Типы ссылок
https://habr.com/ru/post/143468/ - Профилирование
https://habr.com/ru/post/349914/ - JMH
https://habr.com/ru/post/260767/ - String pool
